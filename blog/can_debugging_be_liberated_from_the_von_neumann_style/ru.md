# Can Debugging Be Liberated from the von Neumann Style?

## The early history of debugging

Первыми языками программирования были машинные коды и ассемблер. Ассемблерная программа - это последовательность инструкций:

```
mov ax, bx
add ax, dx
shr ax, 1
mov si, ax
add si, si
cmp cx, arr[si]
```


Каждая инструкция меняет состояние программы - регистров и памяти.

При отладке такой программы мы двигаемся по программе инструкция за инструкцией, и можем на каждом шаге обозревать состояние регистров и памяти. __Хотя язык низкоуровневый, модель отладки простая и хорошо отображается на модель языка__

## High-level languages

С появлением высокоуровневых языков, у нас возникло что-то новое. __У нас появились выражения__.

Рассмотрим такую программу, которая вычисляет длину вектора:

```
function vec_len(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1])
}
```

Что мы видим нового по сравнению с ассемблером:

- У нас возникло понятие __значения__ отдельно от регистра или места в памяти в котором оно находится
- В отличие от регистров и memory locations, которые мутабельны, значения иммутабельны
- У нас появились операции над значениями. `+` и `*` - это встроенные операции. Можно также определять кастомные операции. `Math.sqrt` - это кастомная операция, определенная в стандартной библиотеке
- Операции и значения составляют выражения. Выражение берет значение, применяет операцию, и создает новое значение.
- Выражения замкнуты относительно композиции. Мы можем составлять сложные выражения из простых выражений. Промежуточные значения как бы повисают в воздухе. Мы не заботимся о том, в каких ячейках памяти они хранятся

Ассемблерная программа - это __последовательность__ инструкций. Выражение - это __дерево__. В каждой вершине этого дерева у нас есть операция, встроенная или кастомная, которая применяется к иммутабельным значениям, и порождает другие иммутабельные значения. Дерево - это другая, более сложная структура данных чем последовательность.

На низком уровне выражения вычисляются с помощью машинных инструкций. Но нам уже не вполне очевидно, как это происходит.

## Для выражений нужны другие дебаггеры

Если в ассемблерных дебаггерах мы обходили последовательность, то в выражениях нам надо обходить дерево. Когда исполняется программа на обычном языке программирования, то дерево выражений обходится в порядке depth-first. 

**Тут возникает ключевая идея - а что если мы дадим возможность программисту при отладке обходить дерево не в том порядке, как это происходило при выполнении программы, а в произвольном, так как ему это удобно?**

<span id='expression_debugger'>Вот как это реализовано в среде [Leporello.js](https://leporello.tech)</span>. Мы с помощью хоткея выделяем выражение, и видим его значение. Выделять можно любое выражение, и делать это можно в любом порядке:

<video src='./expression.mov' controls></video>

## The von Neumann style

В своей [Turing award лекции](https://dl.acm.org/doi/pdf/10.1145/359576.359579) John Backus вводит понятие the von Neuman style. Термин отсылает нас к [архитектуре фон неймана](https://en.wikipedia.org/wiki/Von_Neumann_architecture). Компьютер фон-неймана состоит из CPU, памяти и шины, которая передает данные между CPU и памятью по одному машинному слову за раз. Бэкус называет эту шину von Neumann bottleneck. По Бэкусу, современные языки программирования - это высокоуровневые компьютеры фон Неймана. 

Современные компьютеры сильно отличаются по архитектуре от примитивной машины фон Неймана. Но что касается дебаггинга, мы до сих пор имеем дело с боттлнеком фон Неймана. В процессе дебаггинга, мы исполняем программу по одной инструкции за раз. У нас при этом нет какой-то более высокоуровневой модели и репрезентации выполнения программы.

По Бэкусу, программы в стиле фон Неймана разделены на два мира - выражения и стейтменты. У выражений есть полезные алгербраическиe свойства, которых лишены стейтменты. Как это относится к дебаггингу? Когда мы имеем дело с выражением, в котором каждая операция преобразует иммутабельные аргументы в иммутабельный результат, у нас есть [богатые инструменты для отладки](#expression_debugger). Со стейтментами у нас нет таких инструментов. Мы можем только исполнять программу стейтмент за стейтментом, без возможности вернуться назад во времени.

В общепринятых языках программирования каждое выражение может обладать сайд-эффектом:

<video src='./debugger_side_effect.mp4' controls></video>

<div style='text-align:center; font-style: italic; margin-bottom: 1em'>Hovering over an expression can produce side-effects</div>

В текущих дебаггерах, мы застряли в стиле фон Неймана. Возникает вопрос поставленный в заглавие этой статьи - can debugging be liberated from the von Neumann style?

## From the von Neumann debugging to functional debugging

В качестве альтернативы стилю фон Неймана Бэкус предлагает функциональное программирование. В функциональном программировании вся программа целиком является одним большим выражением.

Мы можем сформулировать принципы, которые позволят нам перейти от фон Нейман дебаггинга к функциональному дебаггингу:

- Программа - это не последовательность инструкций, которые фетчатся и исполняются слово за словом. Это дерево выражений. 

- Программист должен иметь возможность обходить это дерево в любом порядке, как ему удобно. Для каждой вершины в этом дереве, он должен иметь возможность обозреть аргументы и возвращаемое значение

## Why spreadsheet software is so popular?

Интересный феномен - это популярность электронных таблиц среди непрограммистов. Электронные таблицы крайне интуитивны и легки в освоении. В чем причина? Дело в том, что в основе электронных таблиц лежит функциональная модель.

_"The world’s most widely used programming language is a purely functional language! It’s called Excel. No mutable cells, assignment statements, or sequencing; just pure functions and immutable values"_ - Simon Peyton Jones

При использовании Excel, мы избавлены от дебаггинга в стиле фон Неймана. Мы просто вводим информацию, и значения всех ячеек перерассчитываются. Мы может кликнуть по любой ячейке, и обозреть ее значение.

_"Imagine a spreadsheet where every time you change something you must open a terminal, run the compiler and scan through the cell / value pairs in the printout to see the effects of your change. We wouldn't put up with UX that appalling in any other tool but somehow that is still the state of the art for programming tools."_ - [Jamie Brandon](https://www.scattered-thoughts.net/writing/pain-we-forgot/)


## How Leporello.js breaks free from the von Neumann style

[Leporello.js](https://leporello.tech) рассматривает всю программу целиком как одно огромное выражение-дерево:

<video src='./calltree.mov' controls></video>

На видео вы можете увидеть, как Leporello.js позволяет исследовать дерево вызовов программы. Программист может обходить вершины этого дерева в любом порядке, обозревать значения аргументов, возвращаемое значение, и значения всех промежуточных выражений. 

В Leporello.js устранен боттлнек фон Неймана, в виде необходимости исполнять программу в дебаггере инструкция за инструкцией. В конвенциональных дебаггерах отладка - это процесс, который развивается во времени. Но конвенциональные отладчики не дают нам инструментов, чтобы сделать время осязаемым. Это как программа для видеомонтажа, которая не показывает нам таймлайн, а предлагает вместо этого проматывать каждый раз видео с самого начала.

Из-за того что конвенциональные дебаггеры не дают таймлайн, многие программисты предпочитают вообще не пользоваться интерактивными дебаггерами. Вместо этого, они используют отладочную печать. Строчки в логе отладочной печати выполняют функцию таймлайна, позволяя с помощью прокрутки перемещаться вперед и назад по процессу выполнения программы.

## Breaking free from von Neumann style for imperative languages

Бэкус предлагал функциональное программирование как альтернативу стилю фон Неймана. Можем ли мы освободить императивные языки от дебаггинга в стиле фон Нейманна? Ответ: да! [Недавний релиз Leporello.js](https://leporello.tech/blog/mutable_data/) позволяет функциональный дебаггинг для императивных программ.

## Conclusion

С момента первых языков ассемблера языки программирования сделали огромный шаг вперед. В то же время, мы не видели соответствующего прогресса в отладке программ. Многие программисты вообще не пользуются интерактивными дебаггерами, предпочитая отладочную печать - метод, который был доступен еще в те времена, когда у компьютеров вместо дисплеев были принтеры. Как сказал Brian Kernigan, "Debugging is twice as hard as writing the code in the first place". Чтобы упростить программирование, мы должны думать о том, как сделать дебаггинг более простым. По нашему мнению, большой потенциал лежит в переходе от фон-неймановского дебаггинг к функциональному дебаггингу.
